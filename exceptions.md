# Винятоки
'
Винятки виникають, коли в програмі виникають _виняткові_ (_exceptional_) ситуації. Наприклад, що робити, якщо ви збираєтеся прочитати файл і файл не існує? Або що, якщо ви випадково видалили його, коли програма була запущена? Такі ситуації обробляються за допомогою **винятків**.

Точно так само, якщо ваша програма мала деякі неприпустимі оператори? Це обробляється Python, який **піднімає** свої руки і говорить вам, що є **помилка**.

## Помилки

Розглянемо простий виклик функції `print`. Що, якщо ми напишемо `print` як `Print`? Зверніть увагу на великі літери. У цьому випадку Python _видасть_ синтаксичну помилку.

```python
>>> Print("Hello World")
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
NameError: name 'Print' is not defined
>>> print("Hello World")
Hello World
```

Зверніть увагу, що виникає `NameError`, а також друкується місце, де була виявлена помилка. Це те, що робить **обробник помилок** для цієї помилки.

## Винятоки

Ми будемо **намагатися** читати введення від користувача.  Введіть перший рядок нижче і натисніть клавішу `Enter`.  Коли ваш комп'ютер запропонує вам ввести дані, замість цього натисніть `[ctrl-d]` на Mac або `[ctrl-z]` з Windows і подивіться, що станеться.  (Якщо ви використовуєте Windows, і жоден з варіантів не працює, ви можете спробувати `[ctrl-c]` в командному рядку, щоб створити помилку KeyboardInterrupt замість цього).

```python
>>> s = input('Enter something --> ')
Enter something --> Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
EOFError
```

Python викликає помилку під назвою `EOFError`, що в основному означає, що він знайшов символ *кінця файлу* (*end of file*) (який представлений `ctrl-d`), коли він не очікував його побачити.

## Обробка винятків

Ми можемо обробляти винятки за допомогою `try..except`.  Ми просто ставимо наші звичайні висловлювання всередині try-блоку і ставимо вирази обробки помилок у except-блоці.

Приклад (зберегти як `exceptions_handle.py`):

<pre><code class="lang-python">{% include "./programs/exceptions_handle.py" %}</code></pre>

Вихід:

<pre><code>{% include "./programs/exceptions_handle.txt" %}</code></pre>

** Як Це Працює**

Ми поміщаємо всі оператори, які можуть викликати виключення/помилку всередині блоку `try`, а потім поміщаємо обробники для відповідних помилок/винятків y `except` блоці. except може обробляти одну вказану помилку або виняток або укладений в дужки список помилок / винятків. Якщо імена помилок або винятків не вказані, він буде обробляти _всі_ помилок і виключень.


Зверніть увагу, що з кожним `try` повинeн бути пов'язаний принаймні однин except. В іншому випадку, який сенс буде мати блок `try`?

Якщо яка-небудь помилка або виключенням не обробляється, викликається обробник помилок Python за замовчуванням, який просто зупиняє виконання програми і виводить повідомлення про помилку. Ми вже бачили це в дії раніше.

Ви також можете мати пропозицію `else`, пов'язану з `try..except`. Пропозиція `else` виконується, якщо виняток не виникає.

У наступному прикладі ми також побачимо, як отримати об'єкт виключення, щоб ми могли отримати додаткову інформацію.

## Створення Винятків

Ви можете _створити_ (_raise_) виключення з допомогою інструкції `raise`, вказавши ім'я помилки/виключення і об'єкт виключення, який повинен бути _викинутим_ (_thrown_).

Помилка або виключення, яке ви можете викликати, повинні бути класом, який прямо або побічно повинен бути похідним класом класу `Exception`.

Приклад (зберегти як `exceptions_raise.py`):

<pre><code class="lang-python">{% include "./programs/exceptions_raise.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/exceptions_raise.txt" %}</code></pre>

** Як Це Працює**

Тут ми створюємо свій власний тип винятку. Цей новий тип винятку називається `ShortInputException`. Він має два поля - `length`, яка є довжиною даного введення, і `atleast`, яка є мінімальною довжиною, яку очікувала програма.

У `except` ми згадуємо клас помилки, який буде зберігатися `як` ім'я змінної для зберігання відповідного об'єкта error/exception. Це аналогічно параметрам і аргументам у виклику функції. В даному конкретному випадку `except`, ми використовуємо `length` і `atleast` поля об'єкта виключення, щоб надрукувати відповідне повідомлення для користувача.

## Try ... Finally {#try-finally}

Suppose you are reading a file in your program. How do you ensure that the file object is closed properly whether or not an exception was raised? This can be done using the `finally` block.

Зберегти цю програму як exceptions_finally.py`:

<pre><code class="lang-python">{% include "./programs/exceptions_finally.py" %}</code></pre>

Output:

Вихід:

<pre><code>{% include "./programs/exceptions_finally.txt" %}</code></pre>

** Як Це Працює**

Ми робимо звичайне читання файлів, але ми ввели сплячий режим протягом, 2 секунд після друку кожного рядка, використовуючи `time.sleep`, так що програма працює повільно (Python дуже швидкий за своєю природою)(від автора перекладу, але не такий швидкий як С++). Коли програма все ще працює, натисніть "ctrl + c", щоб перервати / скасувати програму.

Зверніть увагу, що виникає виняток KeyboardInterrupt і програма завершує роботу. Однак перед завершенням роботи програми виконується пропозиція `finally`, і об'єкт file завжди закривається.

Зверніть увагу, що змінна, якій присвоєно значення 0 або `None`, або змінна, яка є порожньою послідовністю або колекцією, вважається Python-ом `False`.  Ось чому ми можемо використовувати `if: f` в коді вище.

Також зверніть увагу, що ми використовуємо `sys.stdout.flush()` після `print`, так що він друкує на екран негайно.

## Оператор with {#with}

Отримання ресурсу в блоці `try` і подальше звільнення ресурсу в блоці `finally` є загальним шаблоном. Отже, існує також оператор `with`, який дозволяє це зробити чистим способом:

Зберегти як `exceptions_using_with.py`:

<pre><code class="lang-python">{% include "./programs/exceptions_using_with.py" %}</code></pre>

** Як Це Працює**

Висновок повинен бути таким самим, як у попередньому прикладі. Різниця тут в тому, що ми використовуємо функцію `open` з оператором `with` - ми залишаємо закриття файлу на `with open`.

Що відбувається за лаштунками, це те, що протокол який використовується `with`. Він витягує об'єкт, повернутий оператором `open`, в цьому випадку назвемо його "thefile".

Він _завжди_ викликає '`thefile.__enter__` функцію перед запуском блоку коду під ним і _завжди_ викликає `thefile.__exit__` після завершення блоку коду.

Таким чином, код, який ми написали б в блоці `finally`, повинен автоматично оброблятися методом `__exit__`. Це те, що допомагає нам уникнути необхідності використовувати явно `try..finally`.

Більш детальне обговорення цієї теми виходить за рамки цієї книги, тому, будь ласка, зверніться до [PEP 343] (http://www.python.org/dev/peps/pep-0343/) для вичерпного пояснення.

## Резюме

Ми обговорили використання `try..except` і `try..finally`. Ми бачили, як створювати власні типи винятків і як створювати винятки.

Далі ми розглянемо стандартну бібліотеку Python.