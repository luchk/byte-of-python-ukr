# Модуль

Ви бачили, як можна повторно використовувати код в програмі, визначивши функції один раз. Що робити, якщо ви хочете повторно використовувати ряд функцій в інших програмах, які ви пишете? Як ви вже здогадалися, відповідь - модулі.

Існують різні методи написання модулів, але найпростіший спосіб - створити файл з розширенням`.py', що містить функції і змінні.

Інший метод - написати модулі рідною мовою інтерпритатора, якою був написаний сам інтерпретатор Python. Наприклад, можна написати модулі на мові програмування [C](http://docs.python.org/3/extending/) і при компіляції вони можуть використовуватися з вашого коду Python при використанні стандартного інтерпретатора Python.

Модуль може бути *імпортованим* іншою програмою, щоб використовувати його функціональність. Ось як ми можемо використовувати стандартну бібліотеку Python. По-перше, ми побачимо, як використовувати стандартні бібліотечні модулі.

Приклад (зберегти як `module_using_sys.py`):

<pre><code class="lang-python">{% include "./programs/module_using_sys.py" %}</code></pre>

Вихід:

<pre><code>{% include "./programs/module_using_sys.txt" %}</code></pre>

** Як Це Працює**

По-перше, ми *імпортуємо* модуль `sys` за допомогою оператора `import`. В принципі, це означає, що ми говоримо Python, що ми хочемо використовувати цей модуль. Модуль `sys` містить функціональні можливості, пов'язані з інтерпретатором Python і його середовищем, тобто **сис**темою.

Коли Python виконує інструкцію `import sys`, він шукає модуль sys. У цьому випадку це один з вбудованих модулів, і, отже, Python знає, де його знайти.

Якщо це не скомпільований модуль, тобто модуль, написаний на Python, то інтерпретатор Python буде шукати його в каталогах, перерахованих в змінній`sys.path`. Якщо модуль знайдений, то виконуються інструкції в тілі цього модуля, і модуль стає *доступним* для використання. Зверніть увагу, що ініціалізація виконується тільки при першому імпорті модуля.

Змінна `argv` в модулі `sys` доступна з використанням точкової нотації, тобто `sys.аrgv`. Це ясно вказує, що це ім'я є частиною модуля `sys`. Ще однією перевагою цього підходу є те, що ім'я не конфліктує з будь-якою змінною argv, яка використовується у вашій програмі.

Змінна `sys.argv` являє собою *список* рядків (списки докладно описані в [пізнішому розділі] (./data_structures.md#data-structures)). Зокрема, `sys.argv` містить список *аргументів командного рядка*, тобто аргументи, передані вашій програмі за допомогою командного рядка.

Якщо ви використовуєте IDE для запису і запуску цих програм, знайдіть спосіб вказати аргументи командного рядка для програми в меню.

Тут, коли ми виконуємо `python module_using_sys.py we are argumets`, ми запускаємо модуль `module_using_sys.py` за допомогою команди `python`, і все інше передається програмі як аргументи. Python зберігає аргументи командного рядка в змінній `sys.argv` для подальшого використання.

Пам'ятайте, що ім'я запущеного скрипта завжди є першим елементом в ' sys.список аргв. Так що в цьому випадку у нас буде `module_using_sys.py " as ' sys.argv[0]`," we " as ' sys.argv[1]`," are " as ' sys.argv[2] `і `аргументи" як " sys.argv[3]`. Зверніть увагу, що Python починає відлік з 0, а не 1.

`sys.path` містить список імен каталогів, з яких імпортуються модулі. Зауважте, що перший рядок у поданні `sys.path`порожній - цей порожній рядок вказує на те, що поточний каталог також є частиною `sys.path`, який збігається зі змінною середовища `PYTHONPATH`. Це означає, що ви можете безпосередньо імпортувати модулі, розташовані в поточному каталозі. В іншому випадку вам доведеться помістити свій модуль в один з каталогів, перерахованих в `sys.path.`

Зверніть увагу, що поточний каталог - це каталог, з якого запущена програма. Запустіть 'import os; print (os.getcwd()), щоб дізнатися поточний каталог програми.

## Байт-скомпільовані .pyc файли {#pyc}

Імпорт модуля є відносно дорогим справою, тому Python робить деякі трюки, щоб зробити його швидше. Один із способів - створити *байт-скомпільовані* файли з розширенням `.pyc`, що є проміжною формою, в яку Python перетворює програму (пам'ятайте розділ [введення](./about_python.md#interpreted) про те, як працює Python?). Цей `.pyc` файл корисний при імпорті модуля наступного разу з іншої програми - це буде набагато швидше, так як частина обробки, необхідної при імпорті модуля вже зроблено. Крім того, ці байт-скомпільовані файли не залежать від платформи.

Примітка: ці `.pyc` файли зазвичай створюються в тому ж каталозі, що і відповідні `.py` файли. Якщо Python не має дозволу на запис у файли в цій директорії, то `.pyc` файли не будуть створені.

## Оператор from..import {#from-import-statement}

Якщо ви хочете безпосередньо імпортувати змінну `argv` в свою програму (щоб уникнути введення `sys.`все решту що ви там хотіли ввести) , то ви можете використовувати оператор `from SYS import argv`.

> Попередження: загалом, *уникайте* використання оператора `from..import`, замість цього використовуйте оператор import. Це тому, що ваша програма буде уникати зіткнень імен і буде більш читабельною.

Зразок:

```python
from math import sqrt
print("Square root of 16 is", sqrt(16))
```

## `__імя__` (`__name__`) модуля {#module-name}

Кожен модуль має ім'я та оператори в модулі можуть дізнатися ім'я свого модуля. Це зручно для конкретної мети з'ясувати, чи виконується модуль автономно або імпортується. Як згадувалося раніше, при першому імпорті модуля виконується код який міститься в модулі. Ми можемо використовувати це, щоб заставити модуль вести себе по-різному в залежності від того, використовується він сам по собі чи імпортується з іншого модуля. Це може бути досягнуто за допомогою атрибута `__ mane __` модуля.

Приклад (зберегти як `module_using_name.py`):

<pre><code class="lang-python">{% include "./programs/module_using_name.py" %}</code></pre>

Вихід:

<pre><code>{% include "./programs/module_using_name.txt" %}</code></pre>

** Як Це Працює**

Кожен модуль Python має своє `__імя__` (`__name__`). Якщо це `__ main__`, це означає, що модуль запускається автономно користувачем, і ми можемо зробити відповідні дії.

## Створення Власних Модулів

Створити власний модуль насправді дуже легко, ви робили це весь час!  Це тому, що кожна програма Python також є модулем. Ви просто повинні переконатися про наявність `.py` розширення. Наступний приклад повинен прояснити це.

Приклад (зберегти як `mymodule.py`):

<pre><code class="lang-python">{% include "./programs/mymodule.py" %}</code></pre>

Вище був приклад *модуля*. Як ви можете бачити, в ньому немає нічого особливого в порівнянні з нашою звичайною програмою Python. Далі ми побачимо, як використовувати цей модуль в інших наших програмах Python.

Пам'ятайте, що модуль повинен бути поміщений або в той же каталог, що і програма, з якої ми його імпортуємо, або в один з каталогів, перерахованих в `sys.pahh`.

Інший модуль (зберегти як `mymodule_demo.py`):

<pre><code class="lang-python">{% include "./programs/mymodule_demo.py" %}</code></pre>

вивід:

<pre><code>{% include "./programs/mymodule_demo.txt" %}</code></pre>

** Як Це Працює**

Зверніть увагу, що ми використовуємо ту ж точкову (крапкову) нотацію для доступу до елементів модуля. Python повторно використовує одну і ту ж нотацію, щоб нам не потрібно було продовжувати вивчати нові способи робити прості речі.

Тут версія з використанням `from..import` синтаксису (зберегти як `mymodule_demo2.py`):

```python
from mymodule import say_hi, __version__

say_hi()
print('Version', __version__)
```

<pre><code class="lang-python">{% include "./programs/mymodule_demo2.py" %}</code></pre>

Вивід `mymodule_demo2.py` є таким ж самими, що і вивід `mymodule_demo.pyй`.

Зверніть увагу, що якщо в модулі, що імпортує `mymodule`, вже було оголошено ім'я `__ version__`, відбудеться зіткнення.  Це також можливо, тому що це звичайна практика для кожного модуля, щоб оголосити його номер версії, використовуючи це ім'я. Тому завжди рекомендується віддати перевагу оператору `import`, навіть якщо це може зробити вашу програму трохи довшою.

Ви також можете використовувати:

```python
from mymodule import *
```

Це імпортує всі публічні імена, такі як `say_hi`, але не буде імпортувати `__version__`, тому що він починається з подвійного підкреслення.

> Увага: пам'ятайте, що ви повинні уникати використання імпортування зірочкоб, тобто `from mymodule import*`.

<!-- -->


> **Дзен Python**
> 
> Один з керівних принципів Python полягає в тому, що "явне краще, ніж неявне". Виконайте `import this` в Python, щоб дізнатися більше.

## Функція `dir` {#dir-function}

Вбудована функція `dir()` повертає список імен, визначених об'єктом.
Якщо об'єкт є модулем, цей список включає функції, класи та змінні, визначені всередині цього модуля.

Ця функція може приймати аргументи.
Якщо аргументом є ім'я модуля, функція повертає список імен із зазначеного модуля.
Якщо аргумент відсутній, функція повертає список імен з поточного модуля.

Приклад:

```python
$ python
>>> import sys

# отримати імена атрибутів в модулі sys
>>> dir(sys)
['__displayhook__', '__doc__',
'argv', 'builtin_module_names',
'version', 'version_info']
# лише кілька записів, показано тут

# отримати імена атрибутів для поточного модуля
>>> dir()
['__builtins__', '__doc__',
'__name__', '__package__', 'sys']

# створити нову змінну 'a'
>>> a = 5

>>> dir()
['__builtins__', '__doc__', '__name__', '__package__', 'sys', 'a']

# видалити змінну 'а'
>>> del a

>>> dir()
['__builtins__', '__doc__', '__name__', '__package__', 'sys']
```
** Як Це Працює**

Спершу, ми бачимо використання `dir` на імпортованому модулі `sys`. Ми бачимо величезний список атрибутів, які він містить.

Далі ми використовуємо функцію `dir` без передачі параметрів. За замовчуванням повертається список атрибутів поточного модуля. Зверніть увагу, що список імпортованих модулів також є частиною цього списку.

Щоб побачити `dir` в дії, ми визначаємо нову змінну `a` і присвоюємо їй значення, а потім перевіряємо `dir` і спостерігаємо, що в списку появилося ще одне значення з таким самим імям. Ми видаляємо змінну за допомогою оператора `del`, і бачимо що на виході функції `dir` відбулася зміна.

Примітка про функцію `del`: цей оператор використовується для *видалення* змінної/імені, і після запуску оператора в цьому випадку `del a` ви більше не можете отримати доступ до змінної `a` - як ніби вона ніколи не існувала раніше.

Зверніть увагу, що функція `dir()` працює на *будь яких* об'єктах. Наприклад, запустіть `dir(str)` для отримання атрибутів класу `str` (string).

Існує також [`vars()`] (http://docs.python.org/3/library/functions.html#vars) функція, яка потенційно може дати вам атрибути та їх значення, але вона не буде працювати для всіх випадків.

## Пакети

До теперішнього часу ви, мабуть, почали розуміти ієрархію організації ваших програм. Змінні зазвичай йдуть всередині функцій. Функції та глобальні змінні зазвичай знаходяться всередині модулів. Що робити, якщо ви хочете організувати модулі? Ось де пакети входять в картину.

Пакети - це просто папки модулів зі спеціальним `__init__.py` файлом, який вказує Python, що ця папка є спеціальною, оскільки вона містить модулі Python.

Припустимо, ви хочете створити пакет під назвою 'world' з пакетами 'asia', 'africa' і т. д. і ці підпакети, в свою чергу, містити модулі, такі як 'Індія', 'Мадагаскар', і т. д.

Ось як би ви структурували папки:

```
- <some folder present in the sys.path>/
    - world/
        - __init__.py
        - asia/
            - __init__.py
            - india/
                - __init__.py
                - foo.py
        - africa/
            - __init__.py
            - madagascar/
                - __init__.py
                - bar.py
```

Пакети - це просто зручний спосіб ієрархічної організації модулів. Ви побачите багато прикладів цього в [стандартній бібліотеці] (./stdlib.md#stdlib).

## Резюме

Так само, як функції є багаторазовими частинами програм, модулі є базовими програмами. Пакети - це ще одна ієрархія для організації модулів. Стандартна бібліотека, яка поставляється з Python є прикладом такого набору пакетів і модулів.

Ми бачили, як використовувати ці модулі і створювати свої власні модулі.

Далі ми дізнаємося про деякі цікаві поняття, які називаються структурами даних.
