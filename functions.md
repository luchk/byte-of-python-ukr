# Функції

Функції - це багаторазові частини програм. Вони дозволяють дати ім'я блоку операторів, дозволяючи запускати цей блок з використанням зазначеного імені в будь-якому місці вашої програми і будь-яку кількість разів. Це називається викликом функції. Ми вже використовували багато вбудованих функцій, таких як `len` і `range`.

Концепція функції, ймовірно, є найбільш важливим будівельним блоком будь-якого нетривіального програмного забезпечення (на будь-якій мові програмування), тому ми розглянемо різні аспекти функцій у цій главі.

Функції визначаються за допомогою ключового слова `def`. Після цього ключового слова йдк * ідентифікатор * ім'я для функції, за яким йде пара круглих дужок, які можуть включати у себе імена змінних, і наприкінці двокрапка, яка закінчує рядок. Далі йде блок операторів, які є частиною цієї функції. Прикладом покаже, що це насправді дуже просто:

Приклад (зберегти як `function1.py`):

<pre><code class="lang-python">{% include "./programs/function1.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/function1.txt" %}</code></pre>

** Як Це Працює**

Ми визначаємо функцію `say_hello`, використовуючи синтаксис, який описано вище. Ця функція не приймає параметрів і, отже, немає змінних, оголошених в дужках. Параметри функцій просто вводяться в функцію, щоб ми могли передавати їй різні значення і отримувати відповідні результати.

Зверніть увагу, що ми можемо викликати ту саму функцію двічі, що означає, що нам не потрібно писати той самий код знову.

## параметри функції

Функція може приймати параметри, які є значеннями,з якими функція може щось *зробити*.

Параметри вкаязуються всередині пари круглих дужок у визначенні функції, розділених комами. Коли ми викликаємо функцію, ми надаємо значення таким же чином. Зверніть увагу на використовувану термінологію - імена, задані у визначенні функції, називаються *параметрами* (*parameters*), тоді як значення, зазначені у виклику функції, називаються *аргументами* (*arguments*).

Приклад (зберегти як `function_param.py`):

<pre><code class="lang-python">{% include "./programs/function_param.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/function_param.txt" %}</code></pre>

** Як Це Працює**

Тут ми визначили функцію з ім'ям `print_max`, яка використовує два параметри з іменами `a` і `b`.  Ми дізнаємося більше число, використовуючи просту `if..else` конструкцію, а потім роздруковуємо більше число.

При першому виклику функції `print_max`, ми безпосередньо надаємо числа в якості аргументів. У другому випадку ми викликаємо функцію зі змінними в якості аргументів. `print_max(x, y)` призводить до того, що значення аргументу `x`, буде призначений параметру `a` і значення аргументу `y` , буде присвоєне параметру `x`. Функція `print_max` працює однаково в обох випадках.

## локальні змінна

Коли ви оголошуєте змінні всередині визначення функції, вони жодним чином не пов'язані з іншими змінними з тими ж іменами, які використовуються поза функцією, тобто імена змінних є *локальними* для функції. Це називається *scope*  *область видимості* (*маштабом , сферою застосуванням , місцем застосування, область видимості*) змінної. Всі змінні мають область видимості розміром у блок, в якому вони оголошені, починаючи з моменту визначення назви.

Приклад (зберегти як `function_local.py`):

<pre><code class="lang-python">{% include "./programs/function_local.py" %}</code></pre>
Вивід:

<pre><code>{% include "./programs/function_local.txt" %}</code></pre>

** Як Це Працює**

У перший раз, коли ми друкуємо *значення* ім'я *x* з першим рядком в тілі функції, Python використовує значення параметра, оголошеного в головному блоці, над визначенням функції.

Далі, ми присвоюємо значення `2`  `х`. Ім'я `x` є локальним для нашої функції.  Тому, коли ми змінюємо значення `x` у функції  `x`, визначений в основному блоці, залишається незмінним.

У останньому операторі `print` ми виводимо значення `x`, якe визначено в основному блоці, тим самим підтверджуючи, що на нього фактично не впливає локальне призначення в раніше викликаної функції.

## оператор `global` (The `global` statement) {#global-statement}

Якщо ви хочете присвоїти значення імені, визначеному на верхньому рівні програми (тобто не всередині будь-якої області видимості, такої як функції або класи), то ви повинні сказати Python, що ім'я не локальне, а глобальне. Ми робимо це за допомогою оператора `global`. Неможливо призначити значення змінної, визначеної поза функцією, без оператора `global`.

Ви можете використовувати значення таких змінних, визначених поза функцією (за умови, що в функції немає змінної з тим самим ім'ям). Однак це не рекомендується і слід уникати, оскільки читачеві програми стає неясно де знаходиться визначення цієї змінної. Використання оператора `global` дає ясно зрозуміти, що змінна визначена в зовнішньому блоці.

Приклад (зберегти як `function_global.py`):

<pre><code class="lang-python">{% include "./programs/function_global.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/function_global.txt" %}</code></pre>

**Як Це Працює**

Оператор `global` використовується для оголошення, що `x` є глобальною змінною - Отже, коли ми присвоюємо значення `x` всередині функції, ця ж сама зміна відбивається і на змінній яку ми використовуємо у голобальному блоці.

Ви можете вказати кілька глобальних змінних, використовуючи той самий оператор `global`, наприклад `global x, y, z`.

## Значення аргументів за замовчуванням {#default-arguments}

Для деяких функцій можна зробити деякі параметри *необов'язковими* і використовувати значення за замовчуванням, якщо користувач не хоче надавати для них значення. Це робиться за допомогою значень аргументів за замовчуванням. Можна вказати значення аргументів за замовчуванням для настройки шляхом додавання до імені параметра у визначенні функції оператор присвоювання (`=`) і значення за замовчуванням.

Зверніть увагу, що значення аргументу за замовчуванням має бути константою. Точніше, значення аргументу за замовчуванням має бути незмінним - це докладно пояснюється в наступних розділах. А поки просто пам'ятай про це.

Приклад (зберегти як `function_default.py`):

<pre><code class="lang-python">{% include "./programs/function_default.py" %}</code></pre>

Вихід:

<pre><code>{% include "./programs/function_default.txt" %}</code></pre>

** Як Це Працює**

Функція з ім'ям `say` використовується для друку рядка стільки разів, скільки вказано. Якщо не вказати значення, то за замовчуванням рядок друкується тільки один раз. Ми досягаємо цього шляхом завдання значення аргументів за замовчуванням `1` до параметру `times`.

При першому використанні `say` ми надаємо тільки рядок, і вона друкує рядок один раз. У другому використанні `say` ми надаємо як рядок, так і aргумент `5`, який стверджує, що ми хочемо '* сказати *' рядок 5 разів.

> *ОБЕРЕЖНІСТЬ* (застереження)
> 
> Тільки ті параметри, які знаходяться в кінці списку параметрів, можуть бути задані за замовчуванням
> значення, тобто ви не можете мати параметр зі значенням аргументу за замовчуванням, що передує параметру без
> значення за умовчанням в списку параметрів функції.
> 
> Це пов'язано з тим, що значення присвоюються параметрами по позиції. Наприклад, `def func(a,
> b=5)` є валідним, але `def func(a=5, b)` *не валідне*.

## Аргументи Ключових Слів

Якщо у вас є деякі функції з багатьма параметрами, і ви хочете вказати лише деякі з них, то ви можете задати значення таких параметрів, назвавши їх - це називається *keyword arguments* - ми використовуємо ім'я (ключове слово) замість позиції (яку ми використовували весь час), щоб вказати аргументи функції.

Існує дві переваги такого - одне, використання функції простішеє, так як нам не потрібно турбуватися про порядок аргументів. По-друге, ми можемо давати значення тільки тим параметрам, яким ми хочемо, при умові, що інші параметри мають значення аргументів за замовчуванням.

Приклад (зберегти як `function_keyword.py`):

<pre><code class="lang-python">{% include "./programs/function_keyword.py" %}</code></pre>

Output:

Вихід:

<pre><code>{% include "./programs/function_keyword.txt" %}</code></pre>

** Як Це Працює**

Функція `func` має один параметр без значення аргументу за замовчуванням, за яким слідують два параметра із значеннями аргументу за замовчуванням.

У першому використанні, `func (3, 7)`, параметр `a` отримує значення `3`, параметр `b` отримує значення `7` і `c` отримує значення за замовчуванням `10`.

У другому використанні `func(25, c=24)` змінна `a` отримує значення `25` із-за позиції аргументу. Потім параметр `c` отримує значення `24` через іменування, тобто через ключові аргументи. Змінна `b` отримує значення за замовчуванням `5`.

У третьому використанні `func(c=50, a=100)` ми використовуємо аргументи ключових слів для всіх зазначених значень. Зверніть увагу, що ми вказуємо на значення `c` перед  значенням `a`, хоча `a` визначається перед `c` у визначенні функції.

## VarArgs параметри

Іноді може знадобитися визначити функцію, яка може взяти _любу_ кількість параметрів, тобто **змі**нну кількість **арг**уменів (**var**iable number of **arg**uments), це може бути досягнуто з допомогою зірок (зберегти як `function_varargs.py`):

<pre><code class="lang-python">{% include "./programs/function_varargs.py" %}</code></pre>

Вихід:

<pre><code>{% include "./programs/function_varargs.txt" %}</code></pre>

** Як Це Працює**

Коли ми оголошуємо зірчастий параметр, такий як `*param`, то всі аргументи від цієї точки до кінця збираються як кортеж з назвою 'param'.

Аналогічно, коли ми оголошуємо параметр з подвійною зірочкою, такий як `**param`, то всі аргументи ключового слова з цієї точки до кінця збираються як словник під назвою 'param'..

Ми розглянемо кортежі і словники в [більш пізньому розділі](./data_structures.md#data-structures).

## Оператор `return` {#return-statement}

Оператор `return` використовується для *повернення* з функції, тобто виходу з функції. Ми можемо додатково *повертати значення* з функції.

Приклад (зберегти як `function_return.py`):

<pre><code class="lang-python">{% include "./programs/function_return.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/function_return.txt" %}</code></pre>

** Як Це Працює**

Функція `maximum` повертає максимум серед параметрів, в даному випадку чисел, наданих функції. Финкція використовує просте `if..else`, щоб знайти більше значення, а потім *повертає* це значення.

Зверніть увагу, що оператор `return` без значення для повернення ж  еквівалентним оператору `return None`. `None` - це особливий тип у Python, який є нічим. Наприклад, він використовується для вказівки, що змінна не має значення, якщо вона має значення `None`.

Кожна функція неявно містить оператор `return None` в кінці, якщо ви не написали свій власний оператор `return`. Ви можете побачити це, запустивши `print(some_function())`, де функція `some_function` не використовує оператор `return`, наприклад:

```python
def some_function():
    pass
```

Оператор `pass` використовується в Python для вказівки порожнього блоку операторів.

> Порада: існує вбудована функція під назвою `max`, яка вже реалізує функцію 'find maximum', тому використовуйте вбудовану функцію, коли це можливо.

## DocStrings

Python має відмінну функцію під назвою *documentation strings* (*рядки документації*), яка зазвичай називається її коротшим ім'ям *docstrings*. DocStrings є важливим інструментом, який ви повинні використовувати, так як це допомагає документувати програму краще і робить її легшою для зрозуміння. Дивно, але ми навіть можемо отримати `docstring` назад, скажімо, з функції, коли програма фактично запущена!

Приклад (зберегти як `function_docstring.py`):

<pre><code class="lang-python">{% include "./programs/function_docstring.py" %}</code></pre>

Вихід:

<pre><code>{% include "./programs/function_docstring.txt" %}</code></pre>

** Як Це Працює**

Рядок у першому логічному рядку функції-це *docstring* для цієї функції. Зверніть увагу, що DocStrings також застосовуються до [модулів] (./modules.md#modules) і [класів](./oop.md#oop), про яких ми дізнаємося у відповідних розділах.

Docstring є багаторядковим коментарем, де перший рядок починається з великої літери і закінчується крапкою. Потім другий рядок порожній, а потім будь-яке детальне пояснення, починаючи з третього рядка. Вам наполегливо рекомендується * слідувати цьому стрилю написання dosctrings для всіх ваших нетривіальних функцій.

Ми можемо отримати доступ до docstring функції `print_max`, використовуючи атрибут `__doc__` (зверніть увагу на *подвійне нижнє підкреслення*) (ім'я, яке належить) функції. Просто пам'ятайте, що Python розглядає *все* як об'єкт, і це включає в себе функції. Ми дізнаємося більше про об'єкти в розділі про [класах](./oop.md#oop).

Якщо ви використовували `help () ' в Python, то ви вже бачили використання docstrings! Те, що він робить, це просто отримати атрибут `__doc__` цієї функції і відображає його. Ви можете спробувати його на функції зазначеній вище - просто напишіть `help(print_max)` у вашій програмі. Не забудьте натиснути клавішу `q`, щоб вийти з `help`.

Автоматизовані інструменти можуть витягувати документацію з програми таким чином. Тому я *настійно рекомендую* використовувати docstrings для будь-якої нетривіальної функції, яку ви пишете. Команда `pydoc`, яка поставляється з вашим дистрибутивом Python, працює аналогічно `help()` з використанням docstrings.

## Резюме

Ми бачили так багато аспектів функцій, але зверніть увагу, що ми досі не охопили всі їх аспекти. Тим не менш, ми вже розглянули більшу частину того, що ви будете використовувати щодо функцій Python на щоденній основі.

Далі ми побачимо, як використовувати, а також створювати модулі Python.