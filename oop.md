# Обжктно орієнтоване програмування {#oop}

У всіх програмах, які ми написали до цих пір, ми розробляли нашу програму навколо функцій, тобто блоків операторів, які маніпулюють даними. Це називається _процедурно-орієнтований_ спосіб програмування. Існує ще один спосіб організації вашої програми, який полягає в об'єднанні даних і функціональності і обгортанні їх всередині чогось, що називається об'єктом. Це називається _обєктно-орієнтованою_ парадигмою програмування. Велику частину часу ви можете використовувати процедурне програмування, але при написанні великих програм або якщо ви маєте проблему, яка краще підходить для цього методу, ви можете використовувати об'єктно-орієнтованоге програмування.

Класи та об'єкти є двома основними аспектами об'єктно-орієнтованого програмування. **Клас** створює новий _тип_, де **об'єкти** є **екземплярами** класу. Аналогія полягає в тому, що у вас можуть бути змінні типу `int`, що означає, що змінні, які зберігають цілі числа, є екземплярами (об'єктами) класу `int`.

> **Примітка для програмістів які використовують статичні мови**
> 
> Зверніть увагу, що навіть цілі числа обробляються як об'єкти класу `int`. Це не схоже на C++ і Java (до версії 1.5), де цілі числа є примітивними типами.
> 
> Додаткові відомості про клас див. У розділі `help(int)`.
> 
> Програмісти C# і Java 1.5 знайдуть це схожим на концепцію _boxing and unboxing_.

Об'єкти можуть зберігати дані за допомогою звичайних змінних, які _належать_ об'єкту. Змінні, що належать об'єкту або класу, називаються полями. Об'єкти також можуть мати функціональні можливості за допомогою функцій, які _належать_ до класу. Такі функції називаються **методами** класу. Ця термінологія важлива, тому що вона допомагає нам розрізняти функції і змінні, які незалежні, і ті, які належать класу або об'єкту. У сукупності поля і методи можуть називатися атрибутами цього класу.

Поля бувають двох типів - вони можуть належати кожному примірнику/об'єкту класу або самому класу. Вони називаються **змінні екземпляра** і **змінні класу** відповідно.

Клас створюється за допомогою ключового слова `class`. Поля і методи класу перераховані в блоці з відступом.

## `self` {#self}

Методи класу мають тільки одну конкретну відмінність від звичайних функцій - вони повинні мати додаткове ім'я, яке повинно бути додано в початок списку параметрів, але ви **не** даєте значення для цього параметра при виклику методу, Python надасть його. Ця конкретна змінна відноситься до _самого_ об'єкта , і за згодою їй присвоюється ім'я `self`.

Хоча ви можете дати будь-яке ім'я для цього параметра, настійно рекомендується використовувати ім'я `self` - будь-яке інше ім'я безумовно не схвалюється. Є багато переваг у використанні стандартного імені - будь-який читач вашої програми відразу впізнає його, і навіть спеціалізовані IDE (інтегроване середовище розробки) можуть допомогти вам, якщо ви використовуєте `self`.

> **Примітка для програмістів C++ / Java / C#**
> 
> `self` в Python еквівалентний покажчику `this` В C++ і посиланням `this` В Java і C#.

Вам повинно бути цікаво, як Python дає значення для `self` і чому вам не потрібно давати значення для нього. Приклад прояснить це. Скажімо у вас є клас з ім'ям `MyClass` і екземпляр цього класу під назвою `MyObject`. При виклику методу цього об'єкта як `myobject.method(arg1, arg2)`, це автоматично перетворюється Python в `MyClass.method(myobject, arg1, arg2)` - це все `self`.

Це також означає, що якщо у вас є метод, який не приймає аргументів, то у вас все одно повинен бути один аргумент - `self`.

## Класи {#class}

Найпростіший клас показаний в наступному прикладі (зберегти як `oop_simplestclass.py).

<pre><code class="lang-python">{% include "./programs/oop_simplestclass.py" %}</code></pre>

вивід:

<pre><code>{% include "./programs/oop_simplestclass.txt" %}</code></pre>

** Як Це Працює**

Ми створюємо новий клас, використовуючи інструкцію `class` і ім'я класу. За цим йде відступ блоку операторів, які утворюють тіло класу. У цьому випадку ми маємо порожній блок, який вказується за допомогою оператора `pass`.

Далі ми створюємо об'єкт/екземпляр цього класу, використовуючи ім'я класу, за яким слід пара круглих дужок. (Ми дізнаємося [більше про створення екземпляра] (#init) в наступному розділі). Для нашої перевірки ми підтверджуємо, тип змінної, просто друкуючи це. Він говорить нам, що у нас є екземпляр класу Person в модулі __main__.

Зверніть увагу, що також друкується адреса пам'яті комп'ютера, в якій зберігається об'єкт. Адреса буде мати інше значення на вашому комп'ютері, так як Python може зберігати об'єкт скрізь, де він знаходить місце.

## Метод

Ми вже обговорювали, що класи/об'єкти можуть мати методи, подібні до функцій, за винятком того, що у нас є додаткова змінна `self`. Тепер ми побачимо приклад (зберегти як `oop_method.py).

<pre><code class="lang-python">{% include "./programs/oop_method.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/oop_method.txt" %}</code></pre>

** Як Це Працює**

Тут ми бачимо `self` в дії. Зверніть увагу, що метод `say_hi` не приймає параметрів, але все ще має `self` у визначенні функції.

## Метод '__init__ ' {#init}

Існує багато імен методів, які мають особливе значення в класах Python. Тепер ми побачимо значення методу `__init__`.

Метод `__init__` запускається, як тільки створюється екземпляр об'єкта класу. Метод корисний для виконання будь *ініціалізації* (тобто передачі початкових значень об'єкту), яку ви хочете зробити з вашим об'єктом. Зверніть увагу на подвійні підкреслення на початку і в кінці імені.

Приклад (зберегти як `oop_init.py`):

<pre><code class="lang-python">{% include "./programs/oop_init.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/oop_init.txt" %}</code></pre>

**How It Works**

** Як Це Працює**

Тут ми визначаємо метод `__init__` як приймаючий параметр `name` (поряд зі звичайним `self`). Тут ми просто створюємо нове поле, яке також називається `name`. Зауважте, це дві різні змінні, хоча вони обидва називаються "ім'я". Немає проблем, тому що пунктирна нотація `self.name ' означає, що є щось під назвою `name`, яке є частиною об'єкта під назвою `self`, а інше `name` є локальної змінної. Оскільки ми явно вказуємо, яке ім'я ми маємо на увазі, немає ніякої плутанини.

При створенні нового примірника `p` класу `Person` ми вористовуємо ім'я класу, за яким слідують аргументи в круглих дужках: p = Person('Swaroop').

Ми явно не викликаємо метод `__init__`.
У цьому і полягає особливе значення даного методу.

Тепер ми можемо використовувати `self.name` поле в наших методах, що демонструється в методі `say_hi`.

## Клас і об'єктні змінні {#class-obj-vars}

Ми вже обговорювали функцілнальну частини класів і об'єктів (тобто методи), тепер давайте дізнаємося про частину даних. Частина даних, тобто поля, не що інше, як звичайні змінні, які _привязані_ до просторів імен **класів і об'єктів**. Це означає, що ці імена допустимі тільки в контексті цих класів і об'єктів. Ось чому вони називаються _namespaces_.

Існує два типи _полів_ - змінні класу і змінні об'єкта, які класифікуються в залежності від того, клас або об'єкт _володіє_ цими змінними відповідно.

**Змінні класу** є загально доступними - до них можуть звертатися всі екземпляри цього класу. Існує тільки одна копія змінної класу, і коли будь-який один об'єкт вносить зміни в змінну класу, ця зміна буде видно всім іншим екземплярам.

** Об'єктні змінні** належать кожному окремому об'єкту/примірнику класу. У цьому випадку кожен об'єкт має свою власну копію поля, тобто вони не є загальними і жодним чином не пов'язані з полем з тим же ім'ям в іншому примірнику. Приклад зробить це легко зрозуміти (зберегти як `oop_objvar.py`):

<pre><code class="lang-python">{% include "./programs/oop_objvar.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/oop_objvar.txt" %}</code></pre>

** Як Це Працює**

Це довгий приклад, але він допомагає продемонструвати природу змінних класу і об'єкта. Тут `population` відноситься до класу `Robot` і, отже, є змінною класу. Змінна `name` належить об'єкту (вона призначається за допомогою `self`) і, отже, є змінною об'єкта.

Таким чином, ми звертаємося до змінної класу `population` `Robot.population`, а не як `self.population`. Ми посилаємося на змінну об'єкта `name` з `self.name` - записy в методах цього об'єкта. Запам'ятайте цю просту відмінність між змінними класу і об'єкта. Також зверніть увагу, що змінна об'єкта з тим же ім'ям, що й змінна класу, приховає змінну класу!

Замість 'Robot.population`, ми могли б також використовувати `self.__class__.population`, тому що кожен об'єкт відноситься до свого класу через  `self.__class__` атрибут.

`How_many` насправді є методом, який належить до класу, а не до об'єкта. Це означає, що ми можемо визначити його як метод класу або статичний метод в залежності від того, чи потрібно нам знати, до якого класу ми наледимо (частиною якого класу ми є). Оскільки ми посилаємося на змінну класу, давайте використовувати `метод класу`.

Ми відзначили метод `how_many` як метод класу, використовуючи [декоратор](./more.md#decorator).

Декоратори можна представити як ярлик для виклику функції-оболонки (тобто функції, яка "обгортає" іншу функцію, щоб вона могла щось робити до або після внутрішньої функції), тому застосування декоратора `@classmethod` збігається з викликом:

```python
how_many = classmethod(how_many)
```

Зверніть увагу, що метод `__init__` використовується для ініціалізації екземпляра `Robot` з ім'ям. У цьому методі ми збільшуємо кількість `населення` (`population`) на 1, так як у нас є ще один робот додається. Також зверніть увагу, що значення `self.name` є специфічним для кожного об'єкта, який вказує на природу змінних об'єкта.

Пам'ятайте, що ви повинні посилатися на змінні і методи одного і того ж об'єкта, використовуючи `self`. Це називається *посилання на атрибут*.

У цій програмі ми також бачимо використання *docstrings* для класів, а також методів. Ми можемо отримати доступ до класу docstring під час виконання за допомогою `Robot.__doc__` і метод docstring як `Robot.say_hi.__doc__`.

У методі `die` ми просто зменшуємо `Robt.population` населення на 1.

Всі члени класу є відкритими. Один виняток: якщо ви використовуєте члени даних з іменами, що використовують _подвійне підкреслення як префікс_, наприклад `__privatevar`, Python використовує name-mangling, щоб ефективно зробити його приватною змінною.

Таким чином, трюк полягає в тому, що будь-яка змінна, яка повинна використовуватися тільки усередині класу або об'єкта, повинна починатися з підкреслення, а всі інші імена є загальнодоступними і можуть використовуватися іншими класами/об'єктами. Пам'ятайте, що це тільки трюк і Python не примушує його використовувавти (за винятком префікса подвійного підкреслення).

> **Примітка для програмістів C++ / Java / C#**
> 
> Всі члени класу (включаючи члени даних) є _public_ і всі методи є _virtual_ в Python.

## Успадкування

Одним з основних переваг об'єктно-орієнтованого програмування є **повторне використання** коду, і одним із способів досягнення цього є механізм **успадкування**. Спадкування найкраще представити як реалізацію відносин типу **і підтипу** між класами.

Припустимо, ви хочете написати програму, яка повинна відстежувати викладачів і студентів в коледжі. Вони мають деякі загальні характеристики, такі як ім'я, вік та адреса. Вони також мають конкретні характеристики, такі як заробітна плата, курси та відпустки для викладачів і, оцінки і збори для студентів.

Ви можете створити два незалежних класу для кожного типу і обробити їх, але додавання нових загальних характеристик означатиме додавання до обох цих класів одного і тогож самого. Це швидко стає громіздким.

Кращим способом було б створити загальний клас під назвою `SchoolMember`, а потім мати класи вчителя і учня _успадкованого_ з цього класу, тобто вони стануть підтипами цього типу (класу), а потім ми можемо додати конкретні характеристики до цих підтипів.

Такий підхід має багато переваг. Якщо ми додамо/змінимо будь-яку функціональність в `SchoolMember`, це автоматично відіб'ється і на підтипах. Наприклад, можна додати нове поле ID-карти як для вчителів так і для учнів, просто додавши його в клас учасника школи. Однак зміни підтипів не впливають на інші підтипи. Ще одна перевага полягає в тому, що ви можете посилатися на об'єкт вчителя або учня як на об'єкт `SchoolMember`, що може бути корисним у деяких ситуаціях, таких як підрахунок кількості членів школи. Це називається **поліморфізмом**, де підтип може бути замінений в будь-якій ситуації, коли очікується батьківський тип, тобто об'єкт може розглядатися як екземпляр батьківського класу.

Також зверніть увагу, що ми повторно використовуємо код батьківського класу, і нам не потрібно повторювати його в різних класах, як нам довелося б, якщо б ми використовували незалежні класи.

Клас `SchoolMember` в цій ситуації відомий як **базовий клас** або **суперклас**. Класи `Teacher` і `Student` називаються похідними класами або підкласами.

Тепер ми розглянемо цей приклад як програму (зберегти як `oop_subclass.py`):

<pre><code class="lang-python">{% include "./programs/oop_subclass.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/oop_subclass.txt" %}</code></pre>

** Як Це Працює**

Щоб використовувати спадкування, ми вказуємо імена базових класів у кортежі після імені класу у визначенні класу(наприклад, `class Teacher(SchoolMember)`).   Потім ми спостерігаємо, що метод `__init__` базового класу явно викликається з використанням змінної `self`, щоб ми могли ініціалізувати частину базового класу екземпляра в підкласі. Це дуже важливо пам'ятати - оскільки ми визначаємо метод `__init__ ` в підкласах `Teacher` і `Student`, Python не викликає автоматично конструктор базового класу `SchoolMember`, ви повинні явно викликати його самостійно.

Навпаки, якщо ми не визначили метод `__init__` в підкласі, Python автоматично викличе конструктор базового класу.

Поки ми можемо використовувати екземпляри `Student` або `Teacher` як екземпляр `SchoolMember` і метод `tell`  `SchoolMember`, просто набравши `Teacher.tell` або `Student.tell`, замість цього ми визначаємо ще окремий метод `tell` у кожному підкласі (використовуючи метод `tell` `SchoolMember` як частину), щоб адаптувати його для цього підкласу.  Тому що ми зробили це, коли пишемо `Stedent.tell` Python використовує метод `tell` для цього підкласу проти суперкласу.  Однак, якщо б ми не мали методу `tell` у підкласі, Python використовував би метод `tell у суперкласі.  Python завжди починає шукати методи у фактичному типі підкласу, і якщо він нічого не знаходить, він починає шукати методи в базових класах підкласу, один за іншим в порядку, в якому вони вказані в кортежі (тут у нас є тільки 1 базовий клас, але ви можете мати кілька базових класів) у визначенні класу.

Примітка по термінології - якщо в кортежі спадкування вказано більше одного класу, то  це називається **множинне спадкування**.

Параметр `end` використовується в функції `print` в методі `tell()` суперкласу для друку рядка і дозволяє продовжити наступний друк на тому ж рядку. Це трюк, щоб заставити `print` не друкувати символ `\n` (новий рядок) в кінці друку.

## Резюме

Тепер ми вивчили різні аспекти класів і об'єктів, а також різні термінології, пов'язані з ними. Ми також бачили переваги та недоліки об'єктно-орієнтованого програмування. Python дуже об'єктно-орієнтований, і розуміння цих концепцій ретельно допоможе вам у довгостроковій перспективі.

Далі ми дізнаємося, як працювати з введенням/виведенням і як отримати доступ до файлів в Python.