# Більше

До цих пір ми розглянули більшість аспектів Python, які ви будете використовувати. У цьому розділі ми розглянемо ще кілька аспектів, які зроблять наші знання про Python більш всебічними.

## Passing tuples around
## використання кортежів

Ви коли небудь мріяли повернути два значення з функції? Ви можете. Все, що вам потрібно зробити, це використовувати кортеж.

```python
>>> def get_error_details():
...     return (2, 'details')
...
>>> errnum, errstr = get_error_details()
>>> errnum
2
>>> errstr
'details'
```

Зверніть увагу, що використання `a, b = <some expression>` інтерпретує результат виразу як кортеж з двома значеннями.

Це також означає, що найшвидший спосіб свапнути (поміняти місцями) дві змінні в Python це:

```python
>>> a = 5; b = 8
>>> a, b
(5, 8)
>>> a, b = b, a
>>> a, b
(8, 5)
```

## Спеціальні методи

Існують певні методи, такі як `__init__` і `__del__`, які мають особливе значення в класах.

Спеціальні методи використовуються для імітації певної поведінки вбудованих типів. Наприклад, якщо ви хочете використовувати операцію індексування `x[ключ]` для свого класу (так само, як ви використовуєте його для списків і кортежів), то все, що вам потрібно зробити, це реалізувати метод `__getitem__ ()`, і ваша робота буде виконана. Якщо ви подумаєте про це, це те, що сам Python робить для класу `list`!

Деякі корисні спеціальні методи перераховані в наступній таблиці. Якщо ви хочете знати про всі спеціальні методи, [див. посібник](http://docs.python.org/3/reference/datamodel.html#special-method-names).

- `__init__(self, ...)`
    - Цей метод викликається безпосередньо перед тим, як новостворений об'єкт повертається для використання.

- `__del__(self)`
    - Викликається безпосередньо перед знищенням об'єкта (який має непередбачувані тайміги, тому уникайте використання цього)

- `__str__(self)`
    - Викликається при використанні функції `print` або при використанні `str()`.

- `__lt__(self, other)`
    - Викликається при використанні оператора _менше за_ ( < ). Точно так само існують спеціальні методи для всіх інших операторів ( + , > і т. д.)

- `__getitem__(self, key)`
    - Викликається при використанні операції індексування `x[ключ]`.

- `__len__(self)`
    - Викликається, коли вбудована функція `len()` використовується для об'єкта послідовності.

## Одиночні Блоки Операторів

Ми бачили, що кожен блок операторів відокремлений від інших своїм власним рівнем відступу. Ну, є один нюанс. Якщо ваш блок операторів містить тільки один оператор, то ви можете вказати його в тому же рядку, скажімо, умовного оператора або оператора циклу. У наступному прикладі це повинно бути ясно:

```python
>>> flag = True
>>> if flag: print('Yes')
...
Yes
```

Зверніть увагу, що один оператор використовується на місці, а не як окремий блок.  Хоча ви можете використовувати це для того щоб зробити совю програму _меншою_, я настійно рекомендую уникати цього короткого методу, за винятком перевірки помилок, головним чином тому, що буде набагато простіше додати додатковий оператор, якщо ви використовуєте правильний відступ.

## Лямбда-Форми

Оператор `lambda` використовується для створення нових об'єктів функцій. По суті,  `lambda` приймає параметр, за яким слідує один вираз. Лямбда стає тілом функції. Значення цього виразу повертається новою функцією.

Приклад (зберегти як `more_lambda.py`):

<pre><code class="lang-python">{% include "./programs/more_lambda.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/more_lambda.txt" %}</code></pre>

** Як Це Працює**

Зверніть увагу, що метод `sort` списку може приймати параметр `key`, який визначає, як сортується список (зазвичай ми знаємо тільки про порядку зростання або убування). У нашому випадку ми хочемо зробити власне сортування, і для цього нам потрібно написати функцію. Замість написання окремого блоку def для функції, яка буде використовуватися тільки в цьому місці, ми використовуємо лямбда-вираз для створення нової функції.

## List Comprehension
## Розуміння Списку???

Розуміння списку  (List comprehensions) використовується для отримання нового списку з існуючого списку. Припустимо, у вас є список чисел, і ви хочете отримати відповідний список з усіма числами, помножент на 2, тільки коли саме число більше ніж 2. Розуміння списку (List comprehensions) ідеально підходить для таких ситуацій.

<pre><code class="lang-python">{% include "./programs/more_list_comprehension.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/more_list_comprehension.txt" %}</code></pre>

** Як Це Працює**

Тут ми отримуємо новий список, вказуючи маніпуляцію, яка повинна бути виконана (`2*i`), коли виконується деяка умова (`if i > 2'). Зверніть увагу, що вихідний список залишається без змін.

Перевага використання розуміння списку (List comprehensions) полягає в тому, що він зменшує кількість шаблонного коду, необхідного при використанні циклів для обробки кожного елемента списку і збереження його у новому списку.

## Отримання кортежів і словників у функції

Існує спеціальний спосіб отримання параметрів функції у вигляді кортежу або словника з використанням префікса `*` або `**` відповідно. Це корисно при прийнятті змінного числа аргументів у функції.

```python
>>> def powersum(power, *args):
...     '''Return the sum of each argument raised to the specified power.'''
...		'''Повертає суму кожного аргументу, зведеного в зазначену ступінь.'''
...     total = 0
...     for i in args:
...         total += pow(i, power)
...     return total
...
>>> powersum(2, 3, 4)
25
>>> powersum(2, 10)
100
```

Оскільки у нас є префікс `*` в змінній `args` , всі додаткові аргументи, передані функції, зберігаються в `args` як кортеж.  Якби замість цього використовувався префікс `**`, додаткові параметри вважалися б парами ключ/значення словника.


## Assert оператор {#assert}

Твердження `assert` використовується для того щоб стверджувати, що щось істинне. Наприклад, якщо ви дуже впевнені, що у вас буде хоча б один елемент у списку, який ви використовуєте, і хочете перевірити це, і викликати помилку, якщо це не так, то оператор `assert` ідеально підходить в цій ситуації. Коли оператор assert не виконується, і `AssertionError` зявляється.
Метод `pop()` видаляє і повертає останній елемент зі списку.

```python
>>> mylist = ['item']
>>> assert len(mylist) >= 1
>>> mylist.pop()
'item'
>>> assert len(mylist) >= 1
Traceback (most recent call last):
  File "<stdin>", line 1, in <module>
AssertionError
```

Твердження `assert` повинно використовуватися розумно. У більшості випадків краще перехоплювати винятки, або обробляти проблему, або відображати повідомлення про помилку користувачеві, а потім завершувати роботу.

## Decorators {#decorator}

## Декоратори {#decoratol}

Декоратори - це ярлик для створення обгортки функцій. Це корисно, щоб "обернути" ('wrap') функціональність з тим же кодом знову і знову. Наприклад, я створив декоратор `retry` для себе, який я можу просто застосувати до будь-якої функції, і якщо під час запуску виникає який небудь виняток, програма пробує зппуститися знову, максимум до 5 разів і з затримкою між кожною спробою. Це особливо корисно в ситуаціях, коли ви намагаєтеся зробити мережевий виклик на віддалений комп'ютер:

<pre><code class="lang-python">{% include "./programs/more_decorator.py" %}</code></pre>

Вивід:

<pre><code>{% include "./programs/more_decorator.txt" %}</code></pre>


** Як Це Працює**

Дивіться:

- [Відео: Python декоратори легко](https://youtu.be/MYAEv3JoenI) 
- http://www.ibm.com/developerworks/linux/library/l-cpdecor.html
- http://toumorokoshi.github.io/dry-principles-through-python-decorators.html

## Відмінності між Python 2 і Python 3 {#two-vs-three}

Перегляньте:

- ["Six" library] (http://pythonhosted.org/six/)
- [Перенесення на Python3] (http://lucumr.pocoo.org/2013/5/21/porting-to-python3-redux/)
- [Досвід Python3 від PyDanny](http://pydanny.com/experiences-with-django-python3.html)
- [Офіційне керівництво Django з портування на Python 3] (https://docs.djangoproject.com/en/dev/topics/python3/)
- [Обговорення переваг python 3.x?](http://www.reddit.com/r/Python/comments/22ovb3/what_are_the_advantages_to_python_3x/)


## Резюме

Ми розглянули ще кілька особливостей Python в цьому розділі, і все ж ми не розглянули всі особливості Python. Однак на даному етапі ми розглянули більшу частину того, що ви будете використовувати на практиці. Цього достатньо для початку роботи з будь-якими програмами, які ви збираєтеся створити.

Далі ми обговоримо, як досліджувати Python далі.